#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# mechanic2 - see github.com/server-mechanic/mechanic2
# ```
# curl https://raw.githubusercontent.com/server-mechanic/mechanic2/master/src/mechanic2 -o $HOME/bin/mechanic2
# ```
#

import os
import shutil
import subprocess
import re
import sys
import optparse

MECH2_SYSTEM_MIGRATION=0
MECH2_USER_MIGRATION=1
MECH2_LOCAL_MIGRATION=2

class Mech2Exception(Exception):
  pass

MECH2_DEBUG=0
MECH2_INFO=1
MECH2_WARNING=2
MECH2_ERROR=3

class Mech2Logger(object):
  def __init__(self, quiet=False):
    self.quiet = quiet
    self.logLevel = MECH2_INFO

  def debug(self, message, *args):
    self._log(MECH2_DEBUG, message, *args)

  def info(self, message, *args):
    self._log(MECH2_INFO, message, *args)

  def warn(self, message, *args):
    self._log(MECH2_WARNING, message, *args)

  def error(self, message, *args):
    self._log(MECH2_ERROR, message, *args)

  def _log(self, level, message, *args):
    if not self.quiet and level >= self.logLevel:
      print(message.format(*args))

logger = Mech2Logger()

class Mech2Env(object):
  def getRealUserHome(self):
    return os.path.expanduser("~{}".format(self.getRealUser()))

  def getRealUser(self):
    return os.environ['USER']

  def isRealUserRoot(self):
    return self.getRealUser() == "root"

  def isEffectiveUserRoot(self):
    return os.geteuid() == 0

class Mech2Migration(object):
  def __init__(self, file, name, type):
    self.file = file
    self.type = type
    self.name = name

  def isSystemMigration(self):
    return self.file == MECH2_SYSTEM_MIGRATION

  def isRootRequired(self):
    return self.isSystemMigration() or re.match("^.*as[_]?(root|admin)\\..*$", self.name.lower())

class Mech2MigrationCollector(object):
  def __init__self(object):
    pass

  def collectMigrations(self, env, config):
    migrations = []
    if env.isEffectiveUserRoot():
      self._collectMigrationsInto(migrations=migrations, dirs=config.systemMigrationDirs, type=MECH2_SYSTEM_MIGRATION)
    self._collectMigrationsInto(migrations=migrations, dirs=config.userMigrationDirs, type=MECH2_USER_MIGRATION)
    self._collectLocalMigrationsInto(migrations)
    migrations.sort(key=lambda m: m.name)
    return migrations

  def _collectLocalMigrationsInto(self, migrations):
    dir = os.getcwd()
    while dir != "/":
      migrationsDir = os.path.join(dir, ".mechanic2", "migration.d")
      if os.path.isdir(migrationsDir):
        self._collectMigrationsInto(migrations, [migrationsDir], MECH2_LOCAL_MIGRATION)
        return
      dir = os.path.dirname(dir)

  def _collectMigrationsInto(self, migrations, dirs, type):
    for dir in dirs:
      if os.path.isdir(dir):
        for file in os.listdir(dir):
          file = os.path.join(dir, file)
          if os.path.isfile(file):
             migration = Mech2Migration(file=file,name=os.path.basename(file),type=type)
             if not migration.file in [m.file for m in migrations]:
               migrations.append(migration)

class Mech2Config(object):
  def __init__(self, env, options):
    self.userMigrationDirs = [ os.path.join(env.getRealUserHome(), ".mechanic2", "migration.d") ]
    self.systemMigrationDirs = [ "/etc/mechanic2/migration.d" ]

class Mech2MigrationExecutor(object):
  def __init__(self):
    pass

  def execute(self, migration, user=None):
    if user is None:
      command = [migration.file]
    else:
      command = ["su", user, "-c", migration.file ]

    migrationProcess = subprocess.Popen(command,bufsize=0,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,stdin=None,shell=False,cwd=os.path.dirname(migration.file))
    while True:
      line = migrationProcess.stdout.readline()
      if not line:
        break;
      logger.info(line.strip())
    exitCode = migrationProcess.wait()
    return exitCode

class Mech2MigrationVerifier(object):
  def __init__(self, env):
    self.env = env

  def verifyMigrations(self, migrations):
    valid = True
    for migration in migrations:
      if not os.access(migration.file, os.X_OK):
        logger.error("{} ({}) is not executable.", migration.name, migration.file)
        valid = False
      if migration.isRootRequired() and not self.env.isEffectiveUserRoot():
        logger.error("{} ({}) required root/admin privileges.", migration.name, migration.file)
        valid = False
    return valid

class Mech2Migrator(object):
  def __init__(self, env, executor):
    self.executor = executor
    self.env = env

  def applyMigrations(self, migrations):
    for migration in migrations:
      logger.info("Applying {}...", migration.name)
      if migration.isRootRequired() and not self.env.isEffectiveUserRoot():
        raise Mech2Exception("{} requires root.".format(migration.file))

      user = None
      if (not migration.isSystemMigration() 
        and not migration.isRootRequired()
        and self.env.isEffectiveUserRoot()
        and not self.env.isRealUserRoot()):
        user = self.env.getRealUser()
      exitCode = self.executor.execute(migration=migration, user=user)
      if exitCode != 0:
        logger.error("{} failed.", migration.name)

def main():
  optParser = optparse.OptionParser()
  optParser.add_option("-q", "--quiet", action="store_true",
                  dest="quiet", default=False,
                  help="don't print anything to stdout")
  optParser.add_option("-v", "--verbose", action="count",
                  dest="logLevel", default=0,
                  help="increase logging output")
  
  (options, args) = optParser.parse_args()
  logger.quiet = options.quiet
  logger.logLevel = logger.logLevel-options.logLevel

  env = Mech2Env()
  config = Mech2Config(env=env, options=options)
  collector = Mech2MigrationCollector()
  migrations = collector.collectMigrations(env=env, config=config)
  verifier = Mech2MigrationVerifier(env=env)
  valid = verifier.verifyMigrations(migrations)
  if not valid:
    return 1
  executor = Mech2MigrationExecutor()
  migrator = Mech2Migrator(env=env, executor=executor)
  migrator.applyMigrations(migrations)
  return 0

if __name__ == "__main__":
  exitCode = main()
  sys.exit(exitCode)
